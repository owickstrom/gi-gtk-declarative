{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"gi-gtk-declarative Declarative GTK+ programming in Haskell Using declarative markup to construct user interfaces, in a purely functional fashion, is a great joy. Instead of imperatively building up stateful objects in IO , you construct a regular data structure describing the user interface to render. In web development, declarative user interfaces are supported not only by HTML and related standards, but more recently also by \"virtual DOM\" technologies, as found in React and Elm. Web technologies have then spread to desktop applications through embedded web views, enabled by technologies like Electron . But what about regular (non-web) GUI frameworks for desktop, like GTK+? We should be able to benefit from the declarative programming model, stealing ideas from virtual DOM implementations and web front end frameworks, while using the battle-tested native GUI technologies on the desktop. This is the goal of gi-gtk-declarative ; a declarative and purely functional programming model for GTK+ user interfaces. The library aims to extend the haskell-gi family of packages as transparently as possible, not having to reimplement or manually wrap large parts of existing GTK+ widgets. Get started by checking out the installation instructions !","title":"gi-gtk-declarative"},{"location":"#gi-gtk-declarative","text":"Declarative GTK+ programming in Haskell Using declarative markup to construct user interfaces, in a purely functional fashion, is a great joy. Instead of imperatively building up stateful objects in IO , you construct a regular data structure describing the user interface to render. In web development, declarative user interfaces are supported not only by HTML and related standards, but more recently also by \"virtual DOM\" technologies, as found in React and Elm. Web technologies have then spread to desktop applications through embedded web views, enabled by technologies like Electron . But what about regular (non-web) GUI frameworks for desktop, like GTK+? We should be able to benefit from the declarative programming model, stealing ideas from virtual DOM implementations and web front end frameworks, while using the battle-tested native GUI technologies on the desktop. This is the goal of gi-gtk-declarative ; a declarative and purely functional programming model for GTK+ user interfaces. The library aims to extend the haskell-gi family of packages as transparently as possible, not having to reimplement or manually wrap large parts of existing GTK+ widgets. Get started by checking out the installation instructions !","title":"gi-gtk-declarative"},{"location":"app-simple/","text":"App.Simple The App.Simple framework, provided by the gi-gtk-declarative-app-simple package, build on gi-gtk-declarative to provide a simple application architecture. It's based on a state reducer, inspired by PureScript's Pux . It also draws inspiration from with the earlier versions of the Elm architecture . App The central abstraction is the App : data App window state event = App { update :: state -> event -> Transition state event , view :: state -> AppView window event , inputs :: [ Producer event IO () ] , initialState :: state } Let's look at the individual parts: The update function transition from the current state, based on an event, to another state. It may also exit the application, using the Exit constructor of Transition . The view function renders the current state as a window widget. AppView is a type alias that constrains the widget to be a window bin widget: type AppView window event = Bin window Widget event inputs is a list of Pipes producers, emitting events that feed into the state reducer loop. This is useful to emit events at regular intervals or from some external source. The initialState is the state value that we begin with. Running the Application The easiest way to run an App is the run function. Given that we have the following definitions: data MyState = ... data MyEvent = ... view' :: AppView Window MyEvent update' :: MyState -> MyEvent -> Transition MyState MyEvent clockTicks :: Producer MyEvent IO () We then define our main action to run an application: main :: IO () main = void $ run App { view = view' , update = update' , inputs = [ clockTicks ] , initialState = Initial } As run returns the last state, we ignore it using void . Accessing the last state can be useful if you want to embed a declarative App inside a larger GTK+ application. Note If you need more control over GTK+ initialization and the setup, for instance when using CSS , use the runLoop function.","title":"App.Simple"},{"location":"app-simple/#appsimple","text":"The App.Simple framework, provided by the gi-gtk-declarative-app-simple package, build on gi-gtk-declarative to provide a simple application architecture. It's based on a state reducer, inspired by PureScript's Pux . It also draws inspiration from with the earlier versions of the Elm architecture .","title":"App.Simple"},{"location":"app-simple/#app","text":"The central abstraction is the App : data App window state event = App { update :: state -> event -> Transition state event , view :: state -> AppView window event , inputs :: [ Producer event IO () ] , initialState :: state } Let's look at the individual parts: The update function transition from the current state, based on an event, to another state. It may also exit the application, using the Exit constructor of Transition . The view function renders the current state as a window widget. AppView is a type alias that constrains the widget to be a window bin widget: type AppView window event = Bin window Widget event inputs is a list of Pipes producers, emitting events that feed into the state reducer loop. This is useful to emit events at regular intervals or from some external source. The initialState is the state value that we begin with.","title":"App"},{"location":"app-simple/#running-the-application","text":"The easiest way to run an App is the run function. Given that we have the following definitions: data MyState = ... data MyEvent = ... view' :: AppView Window MyEvent update' :: MyState -> MyEvent -> Transition MyState MyEvent clockTicks :: Producer MyEvent IO () We then define our main action to run an application: main :: IO () main = void $ run App { view = view' , update = update' , inputs = [ clockTicks ] , initialState = Initial } As run returns the last state, we ignore it using void . Accessing the last state can be useful if you want to embed a declarative App inside a larger GTK+ application. Note If you need more control over GTK+ initialization and the setup, for instance when using CSS , use the runLoop function.","title":"Running the Application"},{"location":"contributing/","text":"Contributing This is an experimental package! Expect breaking changes during the 0.x versions, and be prepared to find bugs, surprising behavior, and missing functionality. If you do find something, or think that documentation could be better, please submit an issue on GitHub . If you want to help develop gi-gtk-declarative: Look around the reported issues on GitHub if there's anything you can pick up. Begin by discussing the issue in the comments, such that we have reached a common understanding of the problem and a design. Announce that you're going to start working on it.","title":"Contributing"},{"location":"contributing/#contributing","text":"This is an experimental package! Expect breaking changes during the 0.x versions, and be prepared to find bugs, surprising behavior, and missing functionality. If you do find something, or think that documentation could be better, please submit an issue on GitHub . If you want to help develop gi-gtk-declarative: Look around the reported issues on GitHub if there's anything you can pick up. Begin by discussing the issue in the comments, such that we have reached a common understanding of the problem and a design. Announce that you're going to start working on it.","title":"Contributing"},{"location":"examples/","text":"Examples To learn more about gi-gtk-declarative, check out the full runnable examples in the repository .","title":"Examples"},{"location":"examples/#examples","text":"To learn more about gi-gtk-declarative, check out the full runnable examples in the repository .","title":"Examples"},{"location":"installation/","text":"Installation To install the gi-gtk-declarative package in your project, follow these steps and guidelines: The gi-gtk-declarative package builds on gi-gtk , and thus depend on the same libraries. First, follow the instructions on how to install GTK+ dependencies using your package manager of choice over at the gi-gtk README . Make sure you're not using gi-gtk and this package with GHC 8.2.x ( read more here )! Once you have the GTK+ system libraries installed, it should be a regular Haskell package install with Cabal, Stack, Nix, or whatever floats your boat. Executables using gi-gtk-declarative must be built with the -threaded option passed to GHC. If you are not seeing a window, check this first. Cabal Example Let's look at an example of using Cabal to build a gi-gtk-declarative project. It's assumed you're running Cabal 2.x, and that you have an existing project to work with. If you don't have a project, and you're unsure how to set one up, have look at Introduction to Cabal . Adding Dependencies Begin by including gi-gtk , gi-gtk-declarative , and gi-gtk-declarative-app-simple in the build-depends list of your library or executable: name : your - project ... executable your - executable build - depends : gi - gtk , gi - gtk - declarative , gi - gtk - declarative - app - simple , ... ghc - options : - threaded default - language : Haskell2010 Note that gi-gtk-declarative-app-simple is not strictly required, unless you want to write your application using the App.Simple architecture. Installing and Building Install dependencies and build your executable: cabal v2-build your-executable You are now ready to explore gi-gtk-declarative! To find inspiration, check out the full runnable examples in the repository , or dive right into the documentation .","title":"Installation"},{"location":"installation/#installation","text":"To install the gi-gtk-declarative package in your project, follow these steps and guidelines: The gi-gtk-declarative package builds on gi-gtk , and thus depend on the same libraries. First, follow the instructions on how to install GTK+ dependencies using your package manager of choice over at the gi-gtk README . Make sure you're not using gi-gtk and this package with GHC 8.2.x ( read more here )! Once you have the GTK+ system libraries installed, it should be a regular Haskell package install with Cabal, Stack, Nix, or whatever floats your boat. Executables using gi-gtk-declarative must be built with the -threaded option passed to GHC. If you are not seeing a window, check this first.","title":"Installation"},{"location":"installation/#cabal-example","text":"Let's look at an example of using Cabal to build a gi-gtk-declarative project. It's assumed you're running Cabal 2.x, and that you have an existing project to work with. If you don't have a project, and you're unsure how to set one up, have look at Introduction to Cabal .","title":"Cabal Example"},{"location":"installation/#adding-dependencies","text":"Begin by including gi-gtk , gi-gtk-declarative , and gi-gtk-declarative-app-simple in the build-depends list of your library or executable: name : your - project ... executable your - executable build - depends : gi - gtk , gi - gtk - declarative , gi - gtk - declarative - app - simple , ... ghc - options : - threaded default - language : Haskell2010 Note that gi-gtk-declarative-app-simple is not strictly required, unless you want to write your application using the App.Simple architecture.","title":"Adding Dependencies"},{"location":"installation/#installing-and-building","text":"Install dependencies and build your executable: cabal v2-build your-executable You are now ready to explore gi-gtk-declarative! To find inspiration, check out the full runnable examples in the repository , or dive right into the documentation .","title":"Installing and Building"},{"location":"attributes/css/","text":"CSS CSS classes are declared using the classes function in the attributes list. It's a set of text values that is added to the underlying GTK+ widget's style context as class names. widget Button [ classes [ \"big-button\" ] , # label := \"CLICK ME\" ] GTK+ supports a subset of CSS. To learn more, see the GTK+ CSS Overview . Note To have any effect, a CSS provider needs to be set up for the GDK screen. See the CSS example in the repository for a demonstration.","title":"CSS"},{"location":"attributes/css/#css","text":"CSS classes are declared using the classes function in the attributes list. It's a set of text values that is added to the underlying GTK+ widget's style context as class names. widget Button [ classes [ \"big-button\" ] , # label := \"CLICK ME\" ] GTK+ supports a subset of CSS. To learn more, see the GTK+ CSS Overview . Note To have any effect, a CSS provider needs to be set up for the GDK screen. See the CSS example in the repository for a demonstration.","title":"CSS"},{"location":"attributes/events/","text":"Events To react to user events in the graphical user interface, GTK+ lets you connect callbacks to signals . This package takes a more declarative approach, and talks about events rather than signals. Widgets emit event values , and these values can be mapped and transformed into other values as the event propagates up the tree of widgets. Pure Event Handlers When working with GTK+ widgets, we transform signals into event values using event handlers. Much like properties , event handlers for signals are declared in the attributes list, using the on function. data ButtonEvent = ButtonClicked counterButton :: Widget ButtonEvent counterButton = widget Button [ # label := \"Click me!\" , on # clicked ButtonClicked ] Some signals in GTK+ carry extra information, supplied as extra parameters to signal callbacks. This is supported in gi-gtk-declarative as well, by passing those parameters to the event handler function. Event Handlers with Arguments Looking at WidgetDirectionChangedCallback in gi-gtk, the callback type for the direction-changed signal, we see that it's a type alias: type WidgetDirectionChangedCallback = TextDirection -> IO Bool In gi-gtk-declarative, when using a pure event handler, the type of the event handler will be TextDirection -> event , where event is the event data type of the widget. In the following example we declare a button and emit an event when it's text direction changes. We map the GTK-specific text direction value to our own type. -- A custom type for text direction data Dir = LTR | RTL -- Our event data type data MyEvent = TextDirectionSet Dir | TextDirectionCleared textDirAwareEntry :: Widget MyEvent textDirAwareEntry = widget Entry [ on # directionChanged toEvent ] where -- Map GTK 'TextDirection' values to our event type: toEvent TextDirectionLtr = TextDirectionSet LTR toEvent TextDirectionRtl = TextDirectionSet RTL toEvent _ = TextDirectionCleared Impure Event Handlers When attaching an event handler to a widget signal, it's often necessary to query the widget for its current property values. Getting properties is not pure, so we need event handlers in IO . Using the onM function instead of on , our event handler returns the event as IO event . Also, the handler will take the widget itself as an extra argument. In the following example we attach an event handler to the color-set signal. The event handler uses getColorButtonRgba to get the current RGBA value from the ColorButton widget, and maps the ColorChanged constructor over the IO action. data ColorEvent = ColorChanged ( Maybe RGBA ) colorButton :: RGBA -> Widget ColorEvent colorButton color = widget ColorButton [ # title := \"Selected color\" , # rgba := color , onM # colorSet toColorEvent ] where toColorEvent :: ColorButton -> IO ColorEvent toColorEvent w = ColorChanged <$> getColorButtonRgba w In case the underlying signal callback type has extra arguments, the impure event handler will be a function of those arguments and the widget as the last argument. The translation can be described like this: type SignalCallback = arg1 -> arg2 -> ... -> argN -> IO () type ImpureEventHandler = arg1 -> arg2 -> ... -> argN -> widget -> IO event Signal Handler Return Values Some signal callbacks in GTK+ have return values other than () . It's common that callbacks return a Bool value, determining whether to propagate the event further or not. One example is WidgetFocusCallback , the callback for the focus signal: type WidgetFocusCallback = DirectionType -> IO Bool In gi-gtk-declarative, the return value type of the event handler will be a tuple of the callback return value and the event to emit. In the case of the focus signal, a pure event handler type would be DirectionType -> (Bool, event) . As described above, impure event handlers return IO actions, and in the case of the focus signal the type would be DirectionType -> IO (Bool, event) . The translation to pure and impure event handlers can be described like this: type SignalCallback = arg1 -> arg2 -> ... -> argN -> IO a -- where 'a' is not '()' type PureEventHandler = arg1 -> arg2 -> ... -> argN -> ( a , event ) type ImpureEventHandler = arg1 -> arg2 -> ... -> argN -> widget -- also including the widget! -> IO ( a , event ) Functors Widgets that emit events have Functor instances, meaning that you can use regular fmap and friends to map event values using pure functions. As an example, say that we have another library provide a clickyButton that emits ButtonEvent s. data ButtonEvent = ButtonClicked clickyButton :: Text -> Widget ButtonEvent In our own widget declaration, we can use the clicky button to increment or decrement some counter, by mapping the ButtonClicked events to values of type MyEvent . import Data.Functor (( $> )) data MyEvent = Incr | Decr incrDecrButtons :: Widget MyEvent incrDecrButtons = container Box [ # orientation := OrientationHorizontal ] [ clickyButton \"-1\" $> Decr , clickyButton \"+1\" $> Incr ] Note (a $> b) is equivalent to (const b <$> a) .","title":"Events"},{"location":"attributes/events/#events","text":"To react to user events in the graphical user interface, GTK+ lets you connect callbacks to signals . This package takes a more declarative approach, and talks about events rather than signals. Widgets emit event values , and these values can be mapped and transformed into other values as the event propagates up the tree of widgets.","title":"Events"},{"location":"attributes/events/#pure-event-handlers","text":"When working with GTK+ widgets, we transform signals into event values using event handlers. Much like properties , event handlers for signals are declared in the attributes list, using the on function. data ButtonEvent = ButtonClicked counterButton :: Widget ButtonEvent counterButton = widget Button [ # label := \"Click me!\" , on # clicked ButtonClicked ] Some signals in GTK+ carry extra information, supplied as extra parameters to signal callbacks. This is supported in gi-gtk-declarative as well, by passing those parameters to the event handler function.","title":"Pure Event Handlers"},{"location":"attributes/events/#event-handlers-with-arguments","text":"Looking at WidgetDirectionChangedCallback in gi-gtk, the callback type for the direction-changed signal, we see that it's a type alias: type WidgetDirectionChangedCallback = TextDirection -> IO Bool In gi-gtk-declarative, when using a pure event handler, the type of the event handler will be TextDirection -> event , where event is the event data type of the widget. In the following example we declare a button and emit an event when it's text direction changes. We map the GTK-specific text direction value to our own type. -- A custom type for text direction data Dir = LTR | RTL -- Our event data type data MyEvent = TextDirectionSet Dir | TextDirectionCleared textDirAwareEntry :: Widget MyEvent textDirAwareEntry = widget Entry [ on # directionChanged toEvent ] where -- Map GTK 'TextDirection' values to our event type: toEvent TextDirectionLtr = TextDirectionSet LTR toEvent TextDirectionRtl = TextDirectionSet RTL toEvent _ = TextDirectionCleared","title":"Event Handlers with Arguments"},{"location":"attributes/events/#impure-event-handlers","text":"When attaching an event handler to a widget signal, it's often necessary to query the widget for its current property values. Getting properties is not pure, so we need event handlers in IO . Using the onM function instead of on , our event handler returns the event as IO event . Also, the handler will take the widget itself as an extra argument. In the following example we attach an event handler to the color-set signal. The event handler uses getColorButtonRgba to get the current RGBA value from the ColorButton widget, and maps the ColorChanged constructor over the IO action. data ColorEvent = ColorChanged ( Maybe RGBA ) colorButton :: RGBA -> Widget ColorEvent colorButton color = widget ColorButton [ # title := \"Selected color\" , # rgba := color , onM # colorSet toColorEvent ] where toColorEvent :: ColorButton -> IO ColorEvent toColorEvent w = ColorChanged <$> getColorButtonRgba w In case the underlying signal callback type has extra arguments, the impure event handler will be a function of those arguments and the widget as the last argument. The translation can be described like this: type SignalCallback = arg1 -> arg2 -> ... -> argN -> IO () type ImpureEventHandler = arg1 -> arg2 -> ... -> argN -> widget -> IO event","title":"Impure Event Handlers"},{"location":"attributes/events/#signal-handler-return-values","text":"Some signal callbacks in GTK+ have return values other than () . It's common that callbacks return a Bool value, determining whether to propagate the event further or not. One example is WidgetFocusCallback , the callback for the focus signal: type WidgetFocusCallback = DirectionType -> IO Bool In gi-gtk-declarative, the return value type of the event handler will be a tuple of the callback return value and the event to emit. In the case of the focus signal, a pure event handler type would be DirectionType -> (Bool, event) . As described above, impure event handlers return IO actions, and in the case of the focus signal the type would be DirectionType -> IO (Bool, event) . The translation to pure and impure event handlers can be described like this: type SignalCallback = arg1 -> arg2 -> ... -> argN -> IO a -- where 'a' is not '()' type PureEventHandler = arg1 -> arg2 -> ... -> argN -> ( a , event ) type ImpureEventHandler = arg1 -> arg2 -> ... -> argN -> widget -- also including the widget! -> IO ( a , event )","title":"Signal Handler Return Values"},{"location":"attributes/events/#functors","text":"Widgets that emit events have Functor instances, meaning that you can use regular fmap and friends to map event values using pure functions. As an example, say that we have another library provide a clickyButton that emits ButtonEvent s. data ButtonEvent = ButtonClicked clickyButton :: Text -> Widget ButtonEvent In our own widget declaration, we can use the clicky button to increment or decrement some counter, by mapping the ButtonClicked events to values of type MyEvent . import Data.Functor (( $> )) data MyEvent = Incr | Decr incrDecrButtons :: Widget MyEvent incrDecrButtons = container Box [ # orientation := OrientationHorizontal ] [ clickyButton \"-1\" $> Decr , clickyButton \"+1\" $> Incr ] Note (a $> b) is equivalent to (const b <$> a) .","title":"Functors"},{"location":"attributes/properties/","text":"Properties GTK+ widgets, being built on the GObject framework, have properties. These are key/value pairs that can be get and set generically. This package uses OverloadedLabels to declare properties and their values for GTK+ widgets. There are many properties available for GTK+ widgets. To find them, use the gi-gtk documentation. Each widget module lists its properties in the bottom of the Haddock page. Properties in the Attributes List In gi-gtk-declarative, the list passed to widgets is not a list of properties, but a list of attributes . The attributes list include property declarations, events , and CSS classes . To declare a property and a value in the attributes list, we use the (:=) operator. Here we construct a button with a specific text label: widget Button [ # label := \"Click Here\" ] In the following example we declare a ScrolledWindow , and set the horizontal scroll bar policy to automatically decide whether the scroll bar should be visible: bin ScrolledWindow [ # hscrollbarPolicy := PolicyTypeAutomatic ] someSuperWideWidget As a final example, we declare a ListBox with the multiple selection mode enabled: container ListBox [ # selectionMode := SelectionModeMultiple ] children","title":"Properties"},{"location":"attributes/properties/#properties","text":"GTK+ widgets, being built on the GObject framework, have properties. These are key/value pairs that can be get and set generically. This package uses OverloadedLabels to declare properties and their values for GTK+ widgets. There are many properties available for GTK+ widgets. To find them, use the gi-gtk documentation. Each widget module lists its properties in the bottom of the Haddock page.","title":"Properties"},{"location":"attributes/properties/#properties-in-the-attributes-list","text":"In gi-gtk-declarative, the list passed to widgets is not a list of properties, but a list of attributes . The attributes list include property declarations, events , and CSS classes . To declare a property and a value in the attributes list, we use the (:=) operator. Here we construct a button with a specific text label: widget Button [ # label := \"Click Here\" ] In the following example we declare a ScrolledWindow , and set the horizontal scroll bar policy to automatically decide whether the scroll bar should be visible: bin ScrolledWindow [ # hscrollbarPolicy := PolicyTypeAutomatic ] someSuperWideWidget As a final example, we declare a ListBox with the multiple selection mode enabled: container ListBox [ # selectionMode := SelectionModeMultiple ] children","title":"Properties in the Attributes List"},{"location":"widgets/bins/","text":"Bins Bins are widgets with exactly one child widget. They are constructed using the bin function, given a GTK+ widget constructor, a list of attributes, and a child widget. bin Window [ # title := \"Example Window\" ] $ widget Label [ # label := \"Nothing here yet.\" ] In some cases, specific types of bins are used as children of other widgets. In the case of ListBox , we use ListBoxRow bins as children. container ListBox [] [ bin ListBoxRow [] $ widget Button [] , bin ListBoxRow [] $ widget CheckButton [] ] To find which GTK+ widgets are bins, use the Haddock documentation of gi-gtk and look for objects with instances of the IsBin type class.","title":"Bins"},{"location":"widgets/bins/#bins","text":"Bins are widgets with exactly one child widget. They are constructed using the bin function, given a GTK+ widget constructor, a list of attributes, and a child widget. bin Window [ # title := \"Example Window\" ] $ widget Label [ # label := \"Nothing here yet.\" ] In some cases, specific types of bins are used as children of other widgets. In the case of ListBox , we use ListBoxRow bins as children. container ListBox [] [ bin ListBoxRow [] $ widget Button [] , bin ListBoxRow [] $ widget CheckButton [] ] To find which GTK+ widgets are bins, use the Haddock documentation of gi-gtk and look for objects with instances of the IsBin type class.","title":"Bins"},{"location":"widgets/containers/","text":"Containers Containers are widgets that may contain multiple child widgets. Some examples of such widgets are Box , ListBox , and Paned . Just like single widgets and bins, the container function takes as arguments a widget constructor and a list of properties . The third argument however, is a collection of child widgets. Container and Children Types Different container widgets use different types to help you construct a valid widget hierarchy. These types are enforcing the existing GTK+ widget rules, that otherwise would be printed as warnings or errors. Things that vary between container widget types are: The types of their child widgets The type of collection used to pass the children as a parameter Box In the case of Box , the collection of child widgets has type [BoxChild event] . container Box [] [ BoxChild defaultBoxChildProperties ( widget Button [] ) , BoxChild defaultBoxChildProperties ( widget CheckButton [] ) ] As BoxChildProperties is a record, it's easy to override the defaults with custom values, specifying how the child should be packed in the box. container Box [] [ BoxChild defaultBoxChildProperties { padding = 10 } ( widget Button [] ) , BoxChild defaultBoxChildProperties { expand = True } ( widget CheckButton [] ) ] For convenience, widgets can be wrapped in BoxChild values automatically using the default box packing properties. container Box [] [ widget Button [] , widget CheckButton [] ] ListBox The collection of child widgets used with ListBox is of type [Bin ListBoxRow Widget event] , where ListBoxRow is the regular constructor defined in the gi-gtk package. Instead of accepting any [Widget event] , the type constrains its usage to only accept proper ListBoxRow widgets as children. container ListBox [] [ bin ListBoxRow [] ( widget Button [] ) , bin ListBoxRow [] ( widget CheckButton [] ) ] Paned The Paned widget in GTK+ has two panes, which contain one widget each. While Paned widgets can be constructed using the container function, the smart constructor paned is recommended. It takes a list of attributes, along with two Pane values. paned [ # wideHandle := True ] ( pane defaultPaneProperties { resize = True } $ widget Label [ # label := \"Left\" ]) ( pane defaultPaneProperties { resize = True , shrink = False } $ widget Label [ # label := \"Right\" ]) Each Pane is constructed using the pane function, which takes a PaneProperties value and a child widget. These pane property values are used to call the underlying pack1 / pack2 functions on the GTK+ widget. Notebook The Notebook widget has multiple children - called \"pages\" - and tabs that allow you to view one page at a time. You should construct Notebooks with the notebook , page , and pageWithTab functions. notebook [] [ page \"First tab label\" ( widget Label [ # label := \"First tab content...\" ]) , pageWithTab ( widget Button [ # label := \"Using a button as the tab label widget\" ]) ( widget Label [ # label := \"Second tab content...\" ]) ]","title":"Containers"},{"location":"widgets/containers/#containers","text":"Containers are widgets that may contain multiple child widgets. Some examples of such widgets are Box , ListBox , and Paned . Just like single widgets and bins, the container function takes as arguments a widget constructor and a list of properties . The third argument however, is a collection of child widgets.","title":"Containers"},{"location":"widgets/containers/#container-and-children-types","text":"Different container widgets use different types to help you construct a valid widget hierarchy. These types are enforcing the existing GTK+ widget rules, that otherwise would be printed as warnings or errors. Things that vary between container widget types are: The types of their child widgets The type of collection used to pass the children as a parameter","title":"Container and Children Types"},{"location":"widgets/containers/#box","text":"In the case of Box , the collection of child widgets has type [BoxChild event] . container Box [] [ BoxChild defaultBoxChildProperties ( widget Button [] ) , BoxChild defaultBoxChildProperties ( widget CheckButton [] ) ] As BoxChildProperties is a record, it's easy to override the defaults with custom values, specifying how the child should be packed in the box. container Box [] [ BoxChild defaultBoxChildProperties { padding = 10 } ( widget Button [] ) , BoxChild defaultBoxChildProperties { expand = True } ( widget CheckButton [] ) ] For convenience, widgets can be wrapped in BoxChild values automatically using the default box packing properties. container Box [] [ widget Button [] , widget CheckButton [] ]","title":"Box"},{"location":"widgets/containers/#listbox","text":"The collection of child widgets used with ListBox is of type [Bin ListBoxRow Widget event] , where ListBoxRow is the regular constructor defined in the gi-gtk package. Instead of accepting any [Widget event] , the type constrains its usage to only accept proper ListBoxRow widgets as children. container ListBox [] [ bin ListBoxRow [] ( widget Button [] ) , bin ListBoxRow [] ( widget CheckButton [] ) ]","title":"ListBox"},{"location":"widgets/containers/#paned","text":"The Paned widget in GTK+ has two panes, which contain one widget each. While Paned widgets can be constructed using the container function, the smart constructor paned is recommended. It takes a list of attributes, along with two Pane values. paned [ # wideHandle := True ] ( pane defaultPaneProperties { resize = True } $ widget Label [ # label := \"Left\" ]) ( pane defaultPaneProperties { resize = True , shrink = False } $ widget Label [ # label := \"Right\" ]) Each Pane is constructed using the pane function, which takes a PaneProperties value and a child widget. These pane property values are used to call the underlying pack1 / pack2 functions on the GTK+ widget.","title":"Paned"},{"location":"widgets/containers/#notebook","text":"The Notebook widget has multiple children - called \"pages\" - and tabs that allow you to view one page at a time. You should construct Notebooks with the notebook , page , and pageWithTab functions. notebook [] [ page \"First tab label\" ( widget Label [ # label := \"First tab content...\" ]) , pageWithTab ( widget Button [ # label := \"Using a button as the tab label widget\" ]) ( widget Label [ # label := \"Second tab content...\" ]) ]","title":"Notebook"},{"location":"widgets/custom-widgets/","text":"Custom Widgets This section is yet to be written. In the meantime, see the CustomWidget example .","title":"Custom Widgets"},{"location":"widgets/custom-widgets/#custom-widgets","text":"This section is yet to be written. In the meantime, see the CustomWidget example .","title":"Custom Widgets"},{"location":"widgets/single-widgets/","text":"Single Widgets Single widgets have no child widgets. They are constructed using the widget function, given a GTK+ widget constructor (defined by the gi-gtk package) and a list of attributes. widget Button [] Properties can be set on widgets with the attributes list. This is described in more detail in Properties . widget Label [ # label := \"Hello, World!\" ]","title":"Single Widgets"},{"location":"widgets/single-widgets/#single-widgets","text":"Single widgets have no child widgets. They are constructed using the widget function, given a GTK+ widget constructor (defined by the gi-gtk package) and a list of attributes. widget Button [] Properties can be set on widgets with the attributes list. This is described in more detail in Properties . widget Label [ # label := \"Hello, World!\" ]","title":"Single Widgets"},{"location":"widgets/the-widget-type/","text":"The Widget Type The Widget type is used to wrap specific widgets types, making it possible to mix different types of widgets in containers. The functions used to construct declarative widgets (e.g. widget , bin , and container ) automatically wrap widgets in the Widget type where needed.","title":"The Widget Type"},{"location":"widgets/the-widget-type/#the-widget-type","text":"The Widget type is used to wrap specific widgets types, making it possible to mix different types of widgets in containers. The functions used to construct declarative widgets (e.g. widget , bin , and container ) automatically wrap widgets in the Widget type where needed.","title":"The Widget Type"}]}